/**
 * @file Led.c
 * @author Seb Madgwick
 * @brief LED driver.
 */

//------------------------------------------------------------------------------
// Includes

#include "definitions.h"
#include "Led.h"
#include "NeoPixels/NeoPixels1.h"
#include "NeoPixels/NeoPixels2.h"
#include "NeoPixels/NeoPixels3.h"
#include "NeoPixels/NeoPixels4.h"
#include "NeoPixels/NeoPixels5.h"
#include "NeoPixels/NeoPixels6.h"
#include "PeripheralBusClockFrequency.h"
#include "Spi/SpiBus1.h"
#include <stddef.h>
#include "Timer/Timer.h"

//------------------------------------------------------------------------------
// Definitions

/**
 * @brief Brightness.
 */
typedef enum {
    BrightnessLow = 6,
    BrightnessMedium = 4,
    BrightnessHigh = 0,
} Brightness;

//------------------------------------------------------------------------------
// Function declarations

static inline __attribute__((always_inline)) void Update(Led * const led, const int counter, const uint64_t ticks);
static inline __attribute__((always_inline)) void SetPwm(Led * const pixel, const LedColour colour, const Brightness brightness);
static inline __attribute__((always_inline)) void SpiBusTransfer(SpiBusClient * const client, volatile void* const data, const size_t numberOfBytes);

//------------------------------------------------------------------------------
// Variables

const LedColour ledColourRed = {.rgb = 0xFF0000};
const LedColour ledColourOrange = {.rgb = 0xFF1F00};
const LedColour ledColourYellow = {.rgb = 0xFFFF00};
const LedColour ledColourGreen = {.rgb = 0x00FF1F};
const LedColour ledColourCyan = {.rgb = 0x00FFFF};
const LedColour ledColourBlue = {.rgb = 0x001FFF};
const LedColour ledColourMagenta = {.rgb = 0xFF00FF};
const LedColour ledColourWhite = {.rgb = 0xFFFFFF};
const LedColour ledColourBlack = {.rgb = 0x000000};

Led led0 = {.pixel = &neoPixels1Pixels[0], .colour = ledColourWhite, .mode = LedModeNormal};
Led led1 = {.pixel = &neoPixels2Pixels[0]};
Led led2 = {.pixel = &neoPixels2Pixels[1]};
Led led3 = {.pixel = &neoPixels2Pixels[2]};
Led led4 = {.pixel = &neoPixels2Pixels[3]};
Led led5 = {.pixel = &neoPixels3Pixels[0]};
Led led6 = {.pixel = &neoPixels3Pixels[1]};
Led led7 = {.pixel = &neoPixels3Pixels[2]};
Led led8 = {.pixel = &neoPixels3Pixels[3]};
Led led9 = {.pixel = &neoPixels4Pixels[0]};
Led led10 = {.pixel = &neoPixels4Pixels[1]};
Led led11 = {.pixel = &neoPixels4Pixels[2]};
Led led12 = {.pixel = &neoPixels4Pixels[3]};
Led led13 = {.pixel = &neoPixels5Pixels[0]};
Led led14 = {.pixel = &neoPixels5Pixels[1]};
Led led15 = {.pixel = &neoPixels5Pixels[2]};
Led led16 = {.pixel = &neoPixels5Pixels[3]};
Led led17 = {.pixel = &neoPixels6Pixels[0]};
Led led18 = {.pixel = &neoPixels6Pixels[1]};
Led led19 = {.pixel = &neoPixels6Pixels[2]};
Led led20 = {.pixel = &neoPixels6Pixels[3]};

static SpiBusClient* spiBusClient1;
static SpiBusClient* spiBusClient2;
static SpiBusClient* spiBusClient3;
static SpiBusClient* spiBusClient4;
static SpiBusClient* spiBusClient5;
static SpiBusClient* spiBusClient6;

//------------------------------------------------------------------------------
// Functions

/**
 * @brief Initialises the module. This function must only be called once, on
 * system startup.
 */
void LedInitialise(void) {

    // Add SPI bus clients
    spiBusClient1 = SpiBus1AddClient(ENABLE_PIN);
    spiBusClient2 = SpiBus1AddClient(ENABLE_CH1_PIN);
    spiBusClient3 = SpiBus1AddClient(ENABLE_CH2_PIN);
    spiBusClient4 = SpiBus1AddClient(ENABLE_CH3_PIN);
    spiBusClient5 = SpiBus1AddClient(ENABLE_CH4_PIN);
    spiBusClient6 = SpiBus1AddClient(ENABLE_CH5_PIN);

    // Configure state update timer
    T6CONbits.TCKPS = 0b111; // 1:256 prescale value
    PR6 = PERIPHERAL_BUS_CLOCK_3_FREQUENCY / 256 / 10; // 10 Hz
    T6CONbits.ON = 1;
    EVIC_SourceStatusClear(INT_SOURCE_TIMER_6);
    EVIC_SourceEnable(INT_SOURCE_TIMER_6);
}

/**
 * @brief Timer interrupt handler. This function should be called by the ISR
 * implementation generated by MPLAB Harmony.
 */
void Timer6InterruptHandler(void) {

    // Update LED states
    static int counter;
    counter++;
    const uint64_t ticks = TimerGetTicks64();
    Update(&led0, counter, ticks);
    Update(&led1, counter, ticks);
    Update(&led2, counter, ticks);
    Update(&led3, counter, ticks);
    Update(&led4, counter, ticks);
    Update(&led5, counter, ticks);
    Update(&led6, counter, ticks);
    Update(&led7, counter, ticks);
    Update(&led8, counter, ticks);
    Update(&led9, counter, ticks);
    Update(&led10, counter, ticks);
    Update(&led11, counter, ticks);
    Update(&led12, counter, ticks);
    Update(&led13, counter, ticks);
    Update(&led14, counter, ticks);
    Update(&led15, counter, ticks);
    Update(&led16, counter, ticks);
    Update(&led17, counter, ticks);
    Update(&led18, counter, ticks);
    Update(&led19, counter, ticks);
    Update(&led20, counter, ticks);

    // Update LEDs
    neoPixels1Pixels[1] = neoPixels1Pixels[0]; // apply to both carpus LEDs
    NeoPixels1Update();
    NeoPixels2Update();
    NeoPixels3Update();
    NeoPixels4Update();
    NeoPixels5Update();
    NeoPixels6Update();
    SpiBusTransfer(spiBusClient1, neoPixels1SpiData, neoPixels1SpiNumberOfBytes);
    SpiBusTransfer(spiBusClient2, neoPixels2SpiData, neoPixels2SpiNumberOfBytes);
    SpiBusTransfer(spiBusClient3, neoPixels3SpiData, neoPixels3SpiNumberOfBytes);
    SpiBusTransfer(spiBusClient4, neoPixels4SpiData, neoPixels4SpiNumberOfBytes);
    SpiBusTransfer(spiBusClient5, neoPixels5SpiData, neoPixels5SpiNumberOfBytes);
    SpiBusTransfer(spiBusClient6, neoPixels6SpiData, neoPixels6SpiNumberOfBytes);

    // Clear interrupt flag
    EVIC_SourceStatusClear(INT_SOURCE_TIMER_6);
}

/**
 * @brief Updates the LED.
 * @param led LED structure.
 * @param counter Counter.
 * @param ticks Ticks.
 */
static inline __attribute__((always_inline)) void Update(Led * const led, const int counter, const uint64_t ticks) {

    // Override
    if (led->overrideEnabled) {
        SetPwm(led, led->overrideColour, BrightnessHigh);
        return;
    }

    // Strobe
    if (ticks < led->strobeTimeout) {
        SetPwm(led, (counter & 1) != 0 ? ledColourWhite : ledColourBlack, BrightnessHigh);
        return;
    }

    // Blink
    if (led->blinkQueue[0].rgb != ledColourBlack.rgb) {
        SetPwm(led, led->blinkQueue[0], BrightnessMedium);
        for (int index = 0; index < (LED_BLINK_QUEUE_LENGTH - 1); index++) {
            led->blinkQueue[index] = led->blinkQueue[index + 1];
        }
        led->blinkQueue[LED_BLINK_QUEUE_LENGTH - 1] = ledColourBlack;
        return;
    }

    // Normal
    switch (led->mode) {
        case LedModeNormal:
            SetPwm(led, led->colour, BrightnessMedium);
            break;
        case LedModeFlashing:
            SetPwm(led, led->colour, (counter & 2) == 0 ? BrightnessMedium : BrightnessLow);
            break;
    }
}

/**
 * @brief Sets the PWM.
 * @param led LED structure.
 * @param colour Colour.
 * @param brightness Brightness.
 */
static inline __attribute__((always_inline)) void SetPwm(Led * const led, const LedColour colour, const Brightness brightness) {
    led->pixel->red = colour.red >> brightness;
    led->pixel->green = colour.green >> brightness;
    led->pixel->blue = colour.blue >> brightness;
}

/**
 * @brief Transfers data if transfer is not in progress.
 * @param client Client.
 * @param data Data.
 * @param numberOfBytes Number of bytes.
 */
static inline __attribute__((always_inline)) void SpiBusTransfer(SpiBusClient * const client, volatile void* const data, const size_t numberOfBytes) {
    if (SpiBus1TransferInProgress(client)) {
        return;
    }
    SpiBus1Transfer(client, data, numberOfBytes, NULL);
}

/**
 * @brief Sets the LED.
 * @param led LED structure.
 * @param colour Colour.
 * @param mode Mode.
 */
void LedSet(Led * const led, const LedColour colour, const LedMode mode) {
    const bool state = EVIC_INT_SourceDisable(INT_SOURCE_TIMER_6);
    led->colour = colour;
    led->mode = mode;
    EVIC_INT_SourceRestore(INT_SOURCE_TIMER_6, state);
}

/**
 * @brief Blinks the LED.
 * @param led LED structure.
 * @param colour Colour.
 * @return Result.
 */
LedResult LedBlink(Led * const led, const LedColour colour) {
    if (led->overrideEnabled) {
        return LedResultError;
    }
    const bool state = EVIC_INT_SourceDisable(INT_SOURCE_TIMER_6);
    for (int index = 0; index < LED_BLINK_QUEUE_LENGTH; index++) {
        if (led->blinkQueue[index].rgb == colour.rgb) {
            break;
        }
        if (led->blinkQueue[index].rgb == ledColourBlack.rgb) {
            led->blinkQueue[index] = colour;
            break;
        }
    }
    EVIC_INT_SourceRestore(INT_SOURCE_TIMER_6, state);
    return LedResultOk;
}

/**
 * @brief Strobes the LED.
 * @param led LED structure.
 * @return Result.
 */
LedResult LedStrobe(Led * const led) {
    if (led->overrideEnabled) {
        return LedResultError;
    }
    const bool state = EVIC_INT_SourceDisable(INT_SOURCE_TIMER_6);
    led->strobeTimeout = TimerGetTicks64() + (5 * TIMER_TICKS_PER_SECOND);
    EVIC_INT_SourceRestore(INT_SOURCE_TIMER_6, state);
    return LedResultOk;
}

/**
 * @brief Overrides the LED.
 * @param led LED structure.
 * @param colour Colour.
 */
void LedOverride(Led * const led, const LedColour colour) {
    const bool state = EVIC_INT_SourceDisable(INT_SOURCE_TIMER_6);
    led->overrideEnabled = true;
    led->overrideColour = colour;
    EVIC_INT_SourceRestore(INT_SOURCE_TIMER_6, state);
}

/**
 * @brief Restores the LED.
 * @param led LED structure.
 */
void LedDisableOverride(Led * const led) {
    const bool state = EVIC_INT_SourceDisable(INT_SOURCE_TIMER_6);
    led->overrideEnabled = false;
    EVIC_INT_SourceRestore(INT_SOURCE_TIMER_6, state);
}

//------------------------------------------------------------------------------
// End of file
